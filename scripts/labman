#!/usr/bin/env python

# ----------------------------------------------------------------------------
# Copyright (c) 2017-, labman development team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file LICENSE, distributed with this software.
# ----------------------------------------------------------------------------
from base64 import b64encode
from uuid import uuid4
from functools import partial
from os.path import join, dirname, abspath, basename, splitext, exists
from glob import glob

import psycopg2
from natsort import natsorted
import click

from labman.db import sql_connection


@click.group()
def labman():
    pass


@labman.command("start_webserver")
@click.option('--port', required=False, type=int,
              help="Port where the webserver will start", default=8181)
def start_webserver(port):
    """Starts the labman webserver"""
    import socket
    import errno
    from os.path import join

    from tornado.httpserver import HTTPServer
    from tornado.ioloop import IOLoop
    from tornado.options import options, parse_command_line

    from labman.gui.webserver import Application
    from labman.db.settings import labman_settings

    # Set up logs
    options.log_file_prefix = join(labman_settings.log_dir,
                                   'labman_%d.log' % port)
    options.logging = 'debug'
    parse_command_line()

    # Create the webserver
    ssl_options = {'certfile': labman_settings.certificate_filepath,
                   'keyfile': labman_settings.key_filepath}
    http_server = HTTPServer(Application(), ssl_options=ssl_options)
    try:
        http_server.listen(port)
    except socket.error as e:
        if e.errno == errno.EADDRINUSE:
            raise RuntimeError(
                "Port %d is already in use. Please choose another "
                "port with --port" % port)
        else:
            raise

    click.echo("Labman started on port %d" % port)
    ioloop = IOLoop.instance()

    ioloop.start()


@labman.command()
def config():
    """Generate labman configuration file"""
    from os.path import expanduser

    from labman.db.configuration_manager import ConfigurationManager

    config_fp = expanduser(click.prompt('Path to the configuration file',
                                        default='~/.labman.cfg'))

    click.echo('Main configuration:')
    test_env = click.prompt('Test environment', default=True)
    log_dir = click.prompt('Log directory', default="/tmp/")
    certificate_filepath = click.prompt(
        'Labman Certificate Filepath', default="")
    key_filepath = click.prompt('Labman Key Filepath', default="")
    cookie_secret = click.prompt(
        'Server cookie secret (default: random)', default=b64encode(
            uuid4().bytes + uuid4().bytes))

    click.echo('Postgres configuration:')
    db_host = click.prompt('Postgres host', default='localhost')
    db_port = click.prompt('Postgres port', default=5432)
    db_name = click.prompt('Database name', default='qiita')
    db_user = click.prompt('Postgres user', default='labman')
    db_password = click.prompt('Postgres user password', hide_input=True,
                               confirmation_prompt=True, default="")
    db_admin_user = click.prompt('Postgres admin user', default='labman')
    db_admin_password = click.prompt(
        'Postgres admin user password', hide_input=True,
        confirmation_prompt=True, default="")

    click.echo('Qiita configuration (for testing purposes):')
    qiita_server_cert = click.prompt('Qiita server certificate', default="")

    ConfigurationManager.create(config_fp, test_env, certificate_filepath,
                                key_filepath, cookie_secret, db_host, db_port,
                                db_name, db_user, db_password, db_admin_user,
                                db_admin_password, log_dir, qiita_server_cert)

@labman.command()
def patch(verbose=False):
    """Bring the labman schema up to the latest patch

    Pulls the current patch from the settings table and applies all subsequent
    patches found in the patches directory.
    """
    get_support_file = partial(join, join(dirname(abspath(__file__)), 
                                          '../labman/db/support_files'))
    patches_dir = get_support_file('patches')

    with sql_connection.TRN:
        sql_connection.TRN.add("SELECT current_patch FROM labman.settings")
        try:
            current_patch = sql_connection.TRN.execute_fetchlast()
        except ValueError:
            # the system doesn't have the settings table so is unpatched
            current_patch = 'unpatched'

        current_sql_patch_fp = join(patches_dir, current_patch)
        corresponding_py_patch = partial(join, patches_dir, 'python_patches')

        sql_glob = join(patches_dir, '*.sql')
        sql_patch_files = natsorted(glob(sql_glob))
        
        if current_patch == 'unpatched':
            next_patch_index = 0
            sql_connection.TRN.add("""CREATE TABLE labman.settings 
                                      (current_patch varchar not null)""")
            sql_connection.TRN.add("""INSERT INTO labman.settings
                                      (current_patch) VALUES ('unpatched')""")
            sql_connection.TRN.execute()
        elif current_sql_patch_fp not in sql_patch_files:
            raise RuntimeError("Cannot find patch file %s" % current_patch)
        else:
            next_patch_index = sql_patch_files.index(current_sql_patch_fp) + 1

    patch_update_sql = "UPDATE labman.settings SET current_patch = %s"

    for sql_patch_fp in sql_patch_files[next_patch_index:]:
        sql_patch_filename = basename(sql_patch_fp)

        py_patch_fp = corresponding_py_patch(
            splitext(basename(sql_patch_fp))[0] + '.py')
        py_patch_filename = basename(py_patch_fp)

        with sql_connection.TRN:
            with open(sql_patch_fp, newline=None) as patch_file:
                if verbose:
                    print('\tApplying patch %s...' % sql_patch_filename)
                sql_connection.TRN.add(patch_file.read())
                sql_connection.TRN.add(
                    patch_update_sql, [sql_patch_filename])

            sql_connection.TRN.execute()

            if exists(py_patch_fp):
                if verbose:
                    print('\t\tApplying python patch %s...'
                          % py_patch_filename)
                with open(py_patch_fp) as py_patch:
                    exec(py_patch.read(), globals())


if __name__ == '__main__':
    labman()
